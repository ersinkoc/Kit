<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Authentication Guide - @oxog/kit</title>
  <link rel="stylesheet" href="../css/style.css">
</head>
<body>
  <nav class="navbar">
    <div class="nav-container">
      <a href="../" class="nav-logo">@oxog/kit</a>
      <ul class="nav-menu">
        <li><a href="../#getting-started">Getting Started</a></li>
        <li><a href="../#modules">Modules</a></li>
        <li><a href="../api/">API Reference</a></li>
        <li><a href="./">Guides</a></li>
        <li><a href="https://github.com/oxog/kit" target="_blank">GitHub</a></li>
      </ul>
    </div>
  </nav>

  <main class="container api-content">
    <div class="api-header">
      <h1>Authentication Guide</h1>
      <p>Implement secure authentication with JWT and password hashing</p>
    </div>

    <section class="section">
      <h2>Password Hashing</h2>
      <p>Always hash passwords before storing them:</p>
      <pre><code class="language-typescript">import { hash } from '@oxog/kit/security';

// Registration
async function registerUser(email: string, password: string) {
  // Hash the password (bcrypt-compatible)
  const hashedPassword = await hash.password(password, {
    rounds: 12, // Cost factor (higher = more secure but slower)
  });

  // Store user with hashed password
  const user = await db.users.create({
    email,
    password: hashedPassword,
  });

  return user;
}

// Login
async function loginUser(email: string, password: string) {
  const user = await db.users.findByEmail(email);
  if (!user) {
    throw new Error('Invalid credentials');
  }

  // Verify password
  const isValid = await hash.verify(password, user.password);
  if (!isValid) {
    throw new Error('Invalid credentials');
  }

  return user;
}</code></pre>
    </section>

    <section class="section">
      <h2>JWT Tokens</h2>
      <pre><code class="language-typescript">import { jwt } from '@oxog/kit/security';

const JWT_SECRET = process.env.JWT_SECRET!;
const JWT_REFRESH_SECRET = process.env.JWT_REFRESH_SECRET!;

// Generate tokens
function generateTokens(user: User) {
  const accessToken = jwt.sign(
    {
      userId: user.id,
      email: user.email,
      role: user.role,
    },
    JWT_SECRET,
    { expiresIn: '15m' } // Short-lived access token
  );

  const refreshToken = jwt.sign(
    { userId: user.id },
    JWT_REFRESH_SECRET,
    { expiresIn: '7d' } // Longer-lived refresh token
  );

  return { accessToken, refreshToken };
}

// Verify access token
function verifyAccessToken(token: string) {
  try {
    return jwt.verify(token, JWT_SECRET);
  } catch (error) {
    return null;
  }
}

// Refresh tokens
async function refreshTokens(refreshToken: string) {
  try {
    const payload = jwt.verify(refreshToken, JWT_REFRESH_SECRET);
    const user = await db.users.findById(payload.userId);

    if (!user) {
      throw new Error('User not found');
    }

    return generateTokens(user);
  } catch (error) {
    throw new Error('Invalid refresh token');
  }
}</code></pre>
    </section>

    <section class="section">
      <h2>Authentication Middleware</h2>
      <pre><code class="language-typescript">import { jwt } from '@oxog/kit/security';

function authMiddleware(req, res, next) {
  const authHeader = req.headers.authorization;

  if (!authHeader?.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'No token provided' });
  }

  const token = authHeader.slice(7);

  try {
    const payload = jwt.verify(token, JWT_SECRET);
    req.user = payload;
    next();
  } catch (error) {
    if (error.message === 'Token expired') {
      return res.status(401).json({
        error: 'Token expired',
        code: 'TOKEN_EXPIRED',
      });
    }
    return res.status(401).json({ error: 'Invalid token' });
  }
}

// Role-based authorization
function requireRole(...roles: string[]) {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({ error: 'Not authenticated' });
    }

    if (!roles.includes(req.user.role)) {
      return res.status(403).json({ error: 'Insufficient permissions' });
    }

    next();
  };
}

// Usage
app.get('/admin', authMiddleware, requireRole('admin'), (req, res) => {
  // Only admins can access
});</code></pre>
    </section>

    <section class="section">
      <h2>Session Management</h2>
      <pre><code class="language-typescript">import { createSessionStore } from '@oxog/kit/data';
import { crypto } from '@oxog/kit/security';

interface SessionData {
  userId: string;
  email: string;
  role: string;
  createdAt: number;
}

const sessions = createSessionStore&lt;SessionData&gt;({
  ttl: 24 * 60 * 60 * 1000, // 24 hours
  maxSessions: 100000,
});

// Create session after login
async function createSession(user: User) {
  const sessionId = sessions.create({
    userId: user.id,
    email: user.email,
    role: user.role,
    createdAt: Date.now(),
  });

  return sessionId;
}

// Session middleware
function sessionMiddleware(req, res, next) {
  const sessionId = req.cookies.sessionId;

  if (!sessionId) {
    return next();
  }

  const session = sessions.get(sessionId);
  if (session) {
    req.session = session.data;
    sessions.touch(sessionId); // Extend expiration
  }

  next();
}

// Logout
function logout(req, res) {
  const sessionId = req.cookies.sessionId;
  if (sessionId) {
    sessions.destroy(sessionId);
  }
  res.clearCookie('sessionId');
  res.json({ message: 'Logged out' });
}</code></pre>
    </section>

    <section class="section">
      <h2>Secure Token Generation</h2>
      <pre><code class="language-typescript">import { crypto } from '@oxog/kit/security';

// Generate secure random tokens
const resetToken = crypto.randomHex(32);      // Password reset
const verifyToken = crypto.randomBase64(24);  // Email verification
const apiKey = crypto.randomHex(32);          // API keys

// Store hashed version (don't store plain tokens)
const hashedToken = hash.sha256(resetToken);
await db.passwordResets.create({
  userId: user.id,
  token: hashedToken,
  expiresAt: new Date(Date.now() + 3600000), // 1 hour
});

// Verify token
async function verifyResetToken(token: string) {
  const hashedToken = hash.sha256(token);
  const reset = await db.passwordResets.findByToken(hashedToken);

  if (!reset || reset.expiresAt < new Date()) {
    throw new Error('Invalid or expired token');
  }

  return reset;
}</code></pre>
    </section>

    <section class="section">
      <h2>Complete Authentication Flow</h2>
      <pre><code class="language-typescript">import express from 'express';
import { jwt, hash, crypto } from '@oxog/kit/security';
import { validate } from '@oxog/kit/validation';

const app = express();

// Schemas
const registerSchema = validate.object({
  email: validate.string().required().email(),
  password: validate.string().required().min(8),
  name: validate.string().required(),
});

const loginSchema = validate.object({
  email: validate.string().required().email(),
  password: validate.string().required(),
});

// Register
app.post('/auth/register', async (req, res) => {
  const result = registerSchema.validate(req.body);
  if (!result.valid) {
    return res.status(400).json({ errors: result.errors });
  }

  const { email, password, name } = result.data;

  // Check if user exists
  const existing = await db.users.findByEmail(email);
  if (existing) {
    return res.status(409).json({ error: 'Email already registered' });
  }

  // Create user
  const hashedPassword = await hash.password(password);
  const user = await db.users.create({
    email,
    password: hashedPassword,
    name,
  });

  // Generate tokens
  const tokens = generateTokens(user);

  res.json({
    user: { id: user.id, email: user.email, name: user.name },
    ...tokens,
  });
});

// Login
app.post('/auth/login', async (req, res) => {
  const result = loginSchema.validate(req.body);
  if (!result.valid) {
    return res.status(400).json({ errors: result.errors });
  }

  const { email, password } = result.data;

  const user = await db.users.findByEmail(email);
  if (!user) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }

  const isValid = await hash.verify(password, user.password);
  if (!isValid) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }

  const tokens = generateTokens(user);

  res.json({
    user: { id: user.id, email: user.email, name: user.name },
    ...tokens,
  });
});

// Refresh token
app.post('/auth/refresh', async (req, res) => {
  const { refreshToken } = req.body;

  try {
    const tokens = await refreshTokens(refreshToken);
    res.json(tokens);
  } catch (error) {
    res.status(401).json({ error: 'Invalid refresh token' });
  }
});

// Protected route
app.get('/profile', authMiddleware, async (req, res) => {
  const user = await db.users.findById(req.user.userId);
  res.json(user);
});</code></pre>
    </section>
  </main>

  <footer class="footer">
    <div class="container">
      <p>@oxog/kit - MIT License</p>
    </div>
  </footer>

  <script src="../js/main.js"></script>
</body>
</html>
